In this file, I have documentated my journey from creating this blockchain from scratch. 
This file mainly contains my notes, explaination of my code for my-own understanding

1. created a blockchain class and it has an empty list (one to store our blockchain, another to store transactions).
2. Block consists of timestamp, a list of transactions, proof and hash of the PREVIOUS block. 
3. Each block contains hash of previous block which makes this blockchain immutable.
4. new_transaction(): adds a transaction to the list, it returns the index of the block. Parameter: sender(str, address), recipient(str, address), amount(int)
5. new_block(): returns a dicitonary named block, parameters: proof(int) which comes from proof-of-work algorithm
6. PoW is how new blocks are created or mined on the blockchain. In bitcoin, the PoW algorithm is called HashBash.
7. hash(block): takes block (dict) as input and return string as output.  				
8. valid_proof: checks if the hash(last_proof, proof) contains 4 leading zeroes, return boolean expression. 

Now the blockchain class is successfully created.

MAIN function:

node_indetifier -> uuid4 to generate a random id, two uuid4 cannot be same, str() convert in string form and replace to remove '-' from the address
blockchain = Blockchain() -> object of class Blockchain

@app. route("/") is a Python decorator that Flask provides to assign URLs in our app to functions easily
@app.route("/") is a function of Flask library for web development
default method is ['GET']

GET -> used to request data from a server
POST -> used to post data on the server


@app.route('/transactions/new', methods=['POST'])
def new_transaction():  
Here, in the case of this code, the request object represents the HTTP request sent to the server, 
and get_json() is a method of the request object that is used to extract the JSON data from the request body.
The resulting data is stored in the values variable.
jsonify -> flask framework function that converts Python objects to a JSON-formatted response
Finally, the return statement sends the JSON response back to the client with a status code of 201. 
The client will receive the response and can then process it as needed.

@app.route('/mine', methods=['GET'])
def mine():
Here, we use the proof of work algorithm to get the next proof, the user gets a reward for mining the proof.


# CONSENSUS ALGORITHM: 
1. register_node(self, address): adds node to the list, node is a set.
2. valid_chain(self, chain): checking if a chain is valid by looping through each block and verifying both the hash and the proof, takes chain(list) as input.
3. resolve_conflicts(self): loops through all neighbouring nodes. This is the consensus algorithm and it resolves by replacing our chain with the longest one in
    the network.
    
these function are added to the class Blockchain. Now, we will a create similar function for our server.

@app.route('/nodes/resolve',methods=['GET'])
def consensus():
replaced is an bool (output from resolve_conflicts() function of blockchain class), depending replaced (whether our chian is replaced or not) we will get respective
response. jsonify is used to convert response into JSON format.

@app.route('/nodes/register',methods=['POST'])
def register_nodes():
get_json() is used to get the JSON data sent in the POST request body. If nodes that has address of value (get_json) is NULL, that error statement will be printed.
for all remaining nodes, they wll be added set of nodes. The response message indicates that new nodes have been added and includes the current list of nodes in 
the blockchain network.

